package dpla.ingestion3.mappers

import dpla.ingestion3.mappers.utils._
import dpla.ingestion3.messages.{IngestMessage, IngestMessageTemplates, MessageCollector}
import dpla.ingestion3.model.DplaMapData.{ExactlyOne, ZeroToMany, ZeroToOne}
import dpla.ingestion3.model._
import dpla.ingestion3.utils.Utils._
import org.json4s.DefaultFormats
import org.json4s.JsonAST._

import scala.collection.mutable.ListBuffer
import scala.util.{Failure, Success, Try}
import scala.xml.NodeSeq

trait Mapper[T, +E] extends IngestMessageTemplates {
  // TODO This no longer needs to return Tuple, could simmply return Option[OreAggregation]
  def map(document: Document[T], mapping: Mapping[T]): (Option[OreAggregation], Option[String])

  /**
    * Performs validation checks against dataProvider values
    *
    * @param values Values generated by provider mapping
    * @param collector Ingest message collector
    * @return Returns mapped EdmAgent or an empty EdmAgent if none mapped
    */
  def validateDataProvider(values: ZeroToMany[EdmAgent])
                          (implicit collector: MessageCollector[IngestMessage]): EdmAgent = {
    // Check for more than one dataProvider mapped
    if (values.size > 1) { collector.add(moreThanOneValueInfo("id", "dataProvider", values.toString())) }

    // Check for required field
    values.headOption match {
      case Some(s) => s
      case None =>
        collector.add(missingRequiredError("id", "dataProvider"))
        emptyEdmAgent
    }
  }

  /**
    * Performs validation checks against edmRights values
    *
    * @param values Values generated by edmRights mapping
    * @param collector Ingest message collector
    * @return Option[URI] edmRights URI
    */
  def validateEdmRights(values: ZeroToMany[URI])
                       (implicit collector: MessageCollector[IngestMessage]): ZeroToOne[URI] = {
    // Check for more than one dataProvider mapped
    if (values.size > 1) { collector.add(moreThanOneValueInfo("id", "edmRights", values.toString())) }
    values.headOption
  }

  /**
    * Performs validation checks against isShownAt values
    *
    * @param values Values generated by isShownAt mapping
    * @param collector Ingest message collector
    * @return ExactlyOne[EdmWebResource] First mapped EdmWebResource or empty EdmWebResource of none mapped
    */
  def validateIsShownAt(values: ZeroToMany[EdmWebResource])
                       (implicit collector: MessageCollector[IngestMessage]): ExactlyOne[EdmWebResource] = {
    // Check for more than one dataProvider mapped
    if (values.size > 1) { collector.add(moreThanOneValueInfo("id", "isShownAt", values.toString())) }
    values.headOption match {
      case Some(s) => s
      case None =>
        collector.add(missingRequiredError("id", "isShownAt"))
        emptyEdmWebResource
    }
  }

  /**
    * Performs validation checks against preview values
    *
    * @param values Values generated by preview mapping
    * @param collector Ingest message collector
    * @return Option[EdmWebResource] preview EdmWebResource
    */
  def validateObject(values: ZeroToMany[EdmWebResource])
                       (implicit collector: MessageCollector[IngestMessage]): ZeroToOne[EdmWebResource] = {
    // Check for more than one dataProvider mapped
    if (values.size > 1) {
      collector.add(moreThanOneValueInfo("id", "preview", values.toString()))
    }
    values.headOption
  }

  /**
    * Performs validation checks against preview values
    *
    * @param values Values generated by preview mapping
    * @param collector Ingest message collector
    * @return Option[EdmWebResource] preview EdmWebResource
    */
  def validatePreview(values: ZeroToMany[EdmWebResource])
                    (implicit collector: MessageCollector[IngestMessage]): ZeroToOne[EdmWebResource] = {
    // Check for more than one dataProvider mapped
    if (values.size > 1) {
      collector.add(moreThanOneValueInfo("id", "preview", values.toString()))
    }
    values.headOption
  }
}

class XmlMapper extends Mapper[NodeSeq, XmlMapping] {
  override def map(document: Document[NodeSeq], mapping: Mapping[NodeSeq]): (Option[OreAggregation], Option[String]) = {

    implicit val msgCollector: MessageCollector[IngestMessage] = new MessageCollector[IngestMessage]

    // Field validation
    val validatedDataProvider = validateDataProvider(mapping.dataProvider(document))
    val validatedEdmRights = validateEdmRights(mapping.edmRights(document))
    val validatedIsShownAt = validateIsShownAt(mapping.isShownAt(document))
    val validatedObject = validateObject(mapping.`object`(document))
    val validatedPreview = validatePreview(mapping.preview(document))

    Try {
      OreAggregation(
        dplaUri = mapping.dplaUri(document),
        dataProvider = validatedDataProvider,
        edmRights = validatedEdmRights,
        hasView = mapping.hasView(document),
        intermediateProvider = mapping.intermediateProvider(document),
        isShownAt = validatedIsShownAt,
        `object` = validatedObject, // full size image
        originalRecord = formatXml(document.get),
        preview = validatedPreview, // thumbnail
        provider = mapping.provider(document),
        sidecar = mapping.sidecar(document),
        sourceResource = DplaSourceResource(
          alternateTitle = mapping.alternateTitle(document),
          collection = mapping.collection(document),
          contributor = mapping.contributor(document),
          creator = mapping.creator(document),
          date = mapping.date(document),
          description = mapping.description(document),
          extent = mapping.extent(document),
          format = mapping.format(document),
          genre = mapping.genre(document),
          identifier = mapping.identifier(document),
          language = mapping.language(document),
          place = mapping.place(document),
          publisher = mapping.publisher(document),
          relation = mapping.relation(document),
          replacedBy = mapping.replacedBy(document),
          replaces = mapping.replaces(document),
          rights = mapping.rights(document),
          rightsHolder = mapping.rightsHolder(document),
          subject = mapping.subject(document),
          temporal = mapping.temporal(document),
          title = mapping.title(document),
          `type` = mapping.`type`(document)
        ),
        messages = msgCollector.getAll()
      )
    } match {
      case Success(s) => (Some(s), None)
      case Failure(f) => {
        implicit val formats: DefaultFormats.type = DefaultFormats
        val providerId = (mapping.sidecar(document) \\ "prehashId").extractOrElse[String]("Unknown")
        msgCollector.add(exception(providerId, f))
        val failedOreAgg = emptyOreAggregation.copy(messages = msgCollector.getAll())
        // Return an empty oreAggregation that contains all the messages generated from failed mapping
        (Some(failedOreAgg), None)
      }
    }
  }
}

class JsonMapper extends Mapper[JValue, JsonMapping] {
  override def map(document: Document[JValue], mapping: Mapping[JValue]): (Option[OreAggregation], Option[String]) = {

    implicit val msgCollector: MessageCollector[IngestMessage] = new MessageCollector[IngestMessage]

    Try (
      OreAggregation(
        dplaUri = mapping.dplaUri(document),
        dataProvider = validateDataProvider(mapping.dataProvider(document)),
        edmRights = validateEdmRights(mapping.edmRights(document)),
        hasView = mapping.hasView(document),
        intermediateProvider = mapping.intermediateProvider(document),
        isShownAt = validateIsShownAt(mapping.isShownAt(document)),
        `object` = validateObject(mapping.`object`(document)), // full size image
        originalRecord = formatJson(document.get),
        preview = validatePreview(mapping.preview(document)), // thumbnail
        provider = mapping.provider(document),
        sidecar = mapping.sidecar(document),
        sourceResource = DplaSourceResource(
          alternateTitle = mapping.alternateTitle(document),
          collection = mapping.collection(document),
          contributor = mapping.contributor(document),
          creator = mapping.creator(document),
          date = mapping.date(document),
          description = mapping.description(document),
          extent = mapping.extent(document),
          format = mapping.format(document),
          genre = mapping.genre(document),
          identifier = mapping.identifier(document),
          language = mapping.language(document),
          place = mapping.place(document),
          publisher = mapping.publisher(document),
          relation = mapping.relation(document),
          replacedBy = mapping.replacedBy(document),
          replaces = mapping.replaces(document),
          rights = mapping.rights(document),
          rightsHolder = mapping.rightsHolder(document),
          subject = mapping.subject(document),
          temporal = mapping.temporal(document),
          title = mapping.title(document),
          `type` = mapping.`type`(document)
        ),
        messages = msgCollector.getAll()
      )
    ) match {
      case Success(s) => (Some(s), None)
      case Failure(f) => {
        implicit val formats: DefaultFormats.type = DefaultFormats
        val providerId = (mapping.sidecar(document) \\ "prehashId").extractOrElse[String]("Unknown")
        msgCollector.add(exception(providerId, f))
        val failedOreAgg = emptyOreAggregation.copy(messages = msgCollector.getAll())
        // Return an empty oreAggregation that contains all the messages generated from failed mapping
        (Some(failedOreAgg), None)
      }
    }

  }
}